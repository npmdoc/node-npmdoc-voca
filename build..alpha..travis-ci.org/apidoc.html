<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://vocajs.com"

    >voca (v1.3.0)</a>
</h1>
<h4>The ultimate JavaScript string library</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.voca">module voca</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.voca">
            function <span class="apidocSignatureSpan"></span>voca
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.camelCase">
            function <span class="apidocSignatureSpan">voca.</span>camelCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.capitalize">
            function <span class="apidocSignatureSpan">voca.</span>capitalize
            <span class="apidocSignatureSpan">(subject, restToLower)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.chain">
            function <span class="apidocSignatureSpan">voca.</span>chain
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.charAt">
            function <span class="apidocSignatureSpan">voca.</span>charAt
            <span class="apidocSignatureSpan">(subject, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.chars">
            function <span class="apidocSignatureSpan">voca.</span>chars
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.codePointAt">
            function <span class="apidocSignatureSpan">voca.</span>codePointAt
            <span class="apidocSignatureSpan">(subject, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.codePoints">
            function <span class="apidocSignatureSpan">voca.</span>codePoints
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.conversion_specification">
            function <span class="apidocSignatureSpan">voca.</span>conversion_specification
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.count">
            function <span class="apidocSignatureSpan">voca.</span>count
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.countGraphemes">
            function <span class="apidocSignatureSpan">voca.</span>countGraphemes
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.countSubstrings">
            function <span class="apidocSignatureSpan">voca.</span>countSubstrings
            <span class="apidocSignatureSpan">(subject, substring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.countWhere">
            function <span class="apidocSignatureSpan">voca.</span>countWhere
            <span class="apidocSignatureSpan">(subject, predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.countWords">
            function <span class="apidocSignatureSpan">voca.</span>countWords
            <span class="apidocSignatureSpan">(subject, pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.decapitalize">
            function <span class="apidocSignatureSpan">voca.</span>decapitalize
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.endsWith">
            function <span class="apidocSignatureSpan">voca.</span>endsWith
            <span class="apidocSignatureSpan">(subject, end, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.escapeHtml">
            function <span class="apidocSignatureSpan">voca.</span>escapeHtml
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.escapeRegExp">
            function <span class="apidocSignatureSpan">voca.</span>escapeRegExp
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.first">
            function <span class="apidocSignatureSpan">voca.</span>first
            <span class="apidocSignatureSpan">(subject, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.graphemeAt">
            function <span class="apidocSignatureSpan">voca.</span>graphemeAt
            <span class="apidocSignatureSpan">(subject, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.graphemes">
            function <span class="apidocSignatureSpan">voca.</span>graphemes
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.includes">
            function <span class="apidocSignatureSpan">voca.</span>includes
            <span class="apidocSignatureSpan">(subject, search, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.indexOf">
            function <span class="apidocSignatureSpan">voca.</span>indexOf
            <span class="apidocSignatureSpan">(subject, search, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.insert">
            function <span class="apidocSignatureSpan">voca.</span>insert
            <span class="apidocSignatureSpan">(subject, toInsert, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isAlpha">
            function <span class="apidocSignatureSpan">voca.</span>isAlpha
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isAlphaDigit">
            function <span class="apidocSignatureSpan">voca.</span>isAlphaDigit
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isBlank">
            function <span class="apidocSignatureSpan">voca.</span>isBlank
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isDigit">
            function <span class="apidocSignatureSpan">voca.</span>isDigit
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isEmpty">
            function <span class="apidocSignatureSpan">voca.</span>isEmpty
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isLowerCase">
            function <span class="apidocSignatureSpan">voca.</span>isLowerCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isNumeric">
            function <span class="apidocSignatureSpan">voca.</span>isNumeric
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isString">
            function <span class="apidocSignatureSpan">voca.</span>isString
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.isUpperCase">
            function <span class="apidocSignatureSpan">voca.</span>isUpperCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.kebabCase">
            function <span class="apidocSignatureSpan">voca.</span>kebabCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.last">
            function <span class="apidocSignatureSpan">voca.</span>last
            <span class="apidocSignatureSpan">(subject, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.lastIndexOf">
            function <span class="apidocSignatureSpan">voca.</span>lastIndexOf
            <span class="apidocSignatureSpan">(subject, search, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.latinise">
            function <span class="apidocSignatureSpan">voca.</span>latinise
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.lowerCase">
            function <span class="apidocSignatureSpan">voca.</span>lowerCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.matches">
            function <span class="apidocSignatureSpan">voca.</span>matches
            <span class="apidocSignatureSpan">(subject, pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.noConflict">
            function <span class="apidocSignatureSpan">voca.</span>noConflict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.pad">
            function <span class="apidocSignatureSpan">voca.</span>pad
            <span class="apidocSignatureSpan">(subject, length, pad)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.padLeft">
            function <span class="apidocSignatureSpan">voca.</span>padLeft
            <span class="apidocSignatureSpan">(subject, length, pad)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.padRight">
            function <span class="apidocSignatureSpan">voca.</span>padRight
            <span class="apidocSignatureSpan">(subject, length, pad)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.prune">
            function <span class="apidocSignatureSpan">voca.</span>prune
            <span class="apidocSignatureSpan">(subject, length, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.repeat">
            function <span class="apidocSignatureSpan">voca.</span>repeat
            <span class="apidocSignatureSpan">(subject, times)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.replace">
            function <span class="apidocSignatureSpan">voca.</span>replace
            <span class="apidocSignatureSpan">(subject, pattern, replacement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.replaceAll">
            function <span class="apidocSignatureSpan">voca.</span>replaceAll
            <span class="apidocSignatureSpan">(subject, pattern, replacement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.reverse">
            function <span class="apidocSignatureSpan">voca.</span>reverse
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.reverseGrapheme">
            function <span class="apidocSignatureSpan">voca.</span>reverseGrapheme
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.search">
            function <span class="apidocSignatureSpan">voca.</span>search
            <span class="apidocSignatureSpan">(subject, pattern, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.slice">
            function <span class="apidocSignatureSpan">voca.</span>slice
            <span class="apidocSignatureSpan">(subject, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.slugify">
            function <span class="apidocSignatureSpan">voca.</span>slugify
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.snakeCase">
            function <span class="apidocSignatureSpan">voca.</span>snakeCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.splice">
            function <span class="apidocSignatureSpan">voca.</span>splice
            <span class="apidocSignatureSpan">(subject, start, deleteCount, toAdd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.split">
            function <span class="apidocSignatureSpan">voca.</span>split
            <span class="apidocSignatureSpan">(subject, separator, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.sprintf">
            function <span class="apidocSignatureSpan">voca.</span>sprintf
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.startsWith">
            function <span class="apidocSignatureSpan">voca.</span>startsWith
            <span class="apidocSignatureSpan">(subject, start, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.stripBom">
            function <span class="apidocSignatureSpan">voca.</span>stripBom
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.stripTags">
            function <span class="apidocSignatureSpan">voca.</span>stripTags
            <span class="apidocSignatureSpan">(subject, allowableTags, replacement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.substr">
            function <span class="apidocSignatureSpan">voca.</span>substr
            <span class="apidocSignatureSpan">(subject, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.substring">
            function <span class="apidocSignatureSpan">voca.</span>substring
            <span class="apidocSignatureSpan">(subject, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.swapCase">
            function <span class="apidocSignatureSpan">voca.</span>swapCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.titleCase">
            function <span class="apidocSignatureSpan">voca.</span>titleCase
            <span class="apidocSignatureSpan">(subject, ignoreWords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.tr">
            function <span class="apidocSignatureSpan">voca.</span>tr
            <span class="apidocSignatureSpan">(subject, from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.trim">
            function <span class="apidocSignatureSpan">voca.</span>trim
            <span class="apidocSignatureSpan">(subject, whitespace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.trimLeft">
            function <span class="apidocSignatureSpan">voca.</span>trimLeft
            <span class="apidocSignatureSpan">(subject, whitespace$$1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.trimRight">
            function <span class="apidocSignatureSpan">voca.</span>trimRight
            <span class="apidocSignatureSpan">(subject, whitespace$$1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.truncate">
            function <span class="apidocSignatureSpan">voca.</span>truncate
            <span class="apidocSignatureSpan">(subject, length, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.unescapeHtml">
            function <span class="apidocSignatureSpan">voca.</span>unescapeHtml
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.upperCase">
            function <span class="apidocSignatureSpan">voca.</span>upperCase
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.vprintf">
            function <span class="apidocSignatureSpan">voca.</span>vprintf
            <span class="apidocSignatureSpan">(format, replacements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.wordWrap">
            function <span class="apidocSignatureSpan">voca.</span>wordWrap
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.words">
            function <span class="apidocSignatureSpan">voca.</span>words
            <span class="apidocSignatureSpan">(subject, pattern, flags)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voca.</span>conversion_specification.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voca.</span>diacritics_map</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voca.</span>surrogate_pair</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">voca.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voca.conversion_specification">module voca.conversion_specification</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.conversion_specification.conversion_specification">
            function <span class="apidocSignatureSpan">voca.</span>conversion_specification
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voca.conversion_specification.prototype">module voca.conversion_specification.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.conversion_specification.prototype.getPaddingCharacter">
            function <span class="apidocSignatureSpan">voca.conversion_specification.prototype.</span>getPaddingCharacter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.conversion_specification.prototype.isPercentLiteral">
            function <span class="apidocSignatureSpan">voca.conversion_specification.prototype.</span>isPercentLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voca.diacritics_map">module voca.diacritics_map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.diacritics_map.getLatinCharacter">
            function <span class="apidocSignatureSpan">voca.diacritics_map.</span>getLatinCharacter
            <span class="apidocSignatureSpan">(character)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voca.surrogate_pair">module voca.surrogate_pair</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.surrogate_pair.getAstralNumberFromSurrogatePair">
            function <span class="apidocSignatureSpan">voca.surrogate_pair.</span>getAstralNumberFromSurrogatePair
            <span class="apidocSignatureSpan">(highSurrogate, lowSurrogate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.surrogate_pair.isHighSurrogate">
            function <span class="apidocSignatureSpan">voca.surrogate_pair.</span>isHighSurrogate
            <span class="apidocSignatureSpan">(codePoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voca.surrogate_pair.isLowSurrogate">
            function <span class="apidocSignatureSpan">voca.surrogate_pair.</span>isLowSurrogate
            <span class="apidocSignatureSpan">(codePoint)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voca" id="apidoc.module.voca">module voca</a></h1>


    <h2>
        <a href="#apidoc.element.voca.voca" id="apidoc.element.voca.voca">
        function <span class="apidocSignatureSpan"></span>voca
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Voca(subject) {
  return new ChainWrapper(subject, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.camelCase" id="apidoc.element.voca.camelCase">
        function <span class="apidocSignatureSpan">voca.</span>camelCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function camelCase(subject) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  return words(subjectString).map(wordToCamel).join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[![travis build](https://img.shields.io/travis/panzerdp/voca.svg)](https://travis-ci.org/panzerdp/voca)
[![code coverage](https://img.shields.io/codecov/c/github/panzerdp/voca.svg)](https://codecov.io/github/panzerdp/voca)
[![npm package](https://img.shields.io/npm/v/voca.svg)](https://www.npmjs.com/package/voca)

Voca is a JavaScript library for manipulating strings. [https://vocajs.com][voca]

```javascript
v.<span class="apidocCodeKeywordSpan">camelCase</span>(&#x27;bird flight&#x27;);              // =&#x3e; &#x27;birdFlight&#x27;
v.sprintf(&#x27;%s costs $%.2f&#x27;, &#x27;Tea&#x27;, 1.5); // =&#x3e; &#x27;Tea costs $1.50&#x27;
v.slugify(&#x27;What a wonderful world&#x27;);     // =&#x3e; &#x27;what-a-wonderful-world&#x27;
```

The Voca library offers helpful functions to make string manipulations comfortable: *change case, trim, pad, slugify,
latinise, sprintf&#x27;y, truncate, escape* and much more.  The *modular design* allows to load the entire library, or
individual functions to minimize the application builds. The library is *fully tested*, *well documented* and *long-term supported
*.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.capitalize" id="apidoc.element.voca.capitalize">
        function <span class="apidocSignatureSpan">voca.</span>capitalize
        <span class="apidocSignatureSpan">(subject, restToLower)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function capitalize(subject, restToLower) {
  var subjectString = coerceToString(subject);
  var restToLowerCaseBoolean = coerceToBoolean(restToLower);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  if (restToLowerCaseBoolean) {
    subjectString = subjectString.toLowerCase();
  }
  return subjectString.substr(0, 1).toUpperCase() + subjectString.substr(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Case
 * @param  {string}  [subject=&#x27;&#x27;]        The string to capitalize.
 * @param  {boolean} [restToLower=false] Convert the rest of `subject` to lower case.
 * @return {string}                      Returns the capitalized string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">capitalize</span>(&#x27;apple&#x27;);
 * // =&#x3e; &#x27;Apple&#x27;
 *
 * v.capitalize(&#x27;aPPle&#x27;, true);
 * // =&#x3e; &#x27;Apple&#x27;
 */
function capitalize(subject, restToLower) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.chain" id="apidoc.element.voca.chain">
        function <span class="apidocSignatureSpan">voca.</span>chain
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain(subject) {
  return new ChainWrapper(subject, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @memberof Chain
* @since 1.0.0
* @function __proto__value
* @return {*} Returns the unwrapped value.
* @example
* v
*  .<span class="apidocCodeKeywordSpan">chain</span>(&#x27;Hello world&#x27;)
*  .replace(&#x27;Hello&#x27;, &#x27;Hi&#x27;)
*  .lowerCase()
*  .slugify()
*  .value()
* // =&#x3e; &#x27;hi-world&#x27;
*
* v(&#x27; Space travel &#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.charAt" id="apidoc.element.voca.charAt">
        function <span class="apidocSignatureSpan">voca.</span>charAt
        <span class="apidocSignatureSpan">(subject, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function charAt(subject, position) {
  var subjectString = coerceToString(subject);
  return subjectString.charAt(position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Chop
 * @param  {string} [subject=&#x27;&#x27;] The string to extract from.
 * @param  {numbers} position The position to get the character.
 * @return {string} Returns the character at specified position.
 * @example
 * v.<span class="apidocCodeKeywordSpan">charAt</span>(&#x27;helicopter&#x27;, 0);
 * // =&#x3e; &#x27;h&#x27;
 *
 * v.charAt(&#x27;helicopter&#x27;, 1);
 * // =&#x3e; &#x27;e&#x27;
 */
function charAt(subject, position) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.chars" id="apidoc.element.voca.chars">
        function <span class="apidocSignatureSpan">voca.</span>chars
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chars(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.split(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function chars
 * @static
 * @since 1.0.0
 * @memberOf Split
 * @param {string} [subject=&#x27;&#x27;] The string to split into characters.
 * @return {Array} Returns the array of characters.
 * @example
 * v.<span class="apidocCodeKeywordSpan">chars</span>(&#x27;cloud&#x27;);
 * // =&#x3e; [&#x27;c&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;d&#x27;]
 */
function chars(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.split(&#x27;&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.codePointAt" id="apidoc.element.voca.codePointAt">
        function <span class="apidocSignatureSpan">voca.</span>codePointAt
        <span class="apidocSignatureSpan">(subject, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function codePointAt(subject, position) {
  var subjectString = coerceToString(subject);
  var subjectStringLength = subjectString.length;
  var positionNumber = coerceToNumber(position);
  positionNumber = nanDefault(positionNumber, 0);
  if (positionNumber &#x3c; 0 || positionNumber &#x3e;= subjectStringLength) {
    return undefined;
  }
  var firstCodePoint = subjectString.charCodeAt(positionNumber);
  var secondCodePoint = void 0;
  if (isHighSurrogate(firstCodePoint) &#x26;&#x26; subjectStringLength &#x3e; positionNumber + 1) {
    secondCodePoint = subjectString.charCodeAt(positionNumber + 1);
    if (isLowSurrogate(secondCodePoint)) {
      return getAstralNumberFromSurrogatePair(firstCodePoint, secondCodePoint);
    }
  }
  return firstCodePoint;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Chop
 * @param  {string} [subject=&#x27;&#x27;] The string to extract from.
 * @param  {number} position The position to get the code point number.
 * @return {number} Returns a non-negative number less than or equal to `0x10FFFF`.
 * @example
 * v.<span class="apidocCodeKeywordSpan">codePointAt</span>(&#x27;rain&#x27;, 1);
 * // =&#x3e; 97, or 0x0061
 *
 * v.codePointAt(&#x27;\uD83D\uDE00 is smile&#x27;, 0); // or &#x27;😀 is smile&#x27;
 * // =&#x3e; 128512, or 0x1F600
 */
function codePointAt(subject, position) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.codePoints" id="apidoc.element.voca.codePoints">
        function <span class="apidocSignatureSpan">voca.</span>codePoints
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function codePoints(subject) {
  var subjectString = coerceToString(subject);
  var subjectStringLength = subjectString.length;
  var codePointArray = [];
  var index = 0;
  var codePointNumber = void 0;
  while (index &#x3c; subjectStringLength) {
    codePointNumber = codePointAt(subjectString, index);
    codePointArray.push(codePointNumber);
    index += codePointNumber &#x3e; 0xFFFF ? 2 : 1;
  }
  return codePointArray;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function codePoints
* @static
* @since 1.0.0
* @memberOf Split
* @param  {string} [subject=&#x27;&#x27;] The string to extract from.
* @return {Array} Returns an array of non-negative numbers less than or equal to `0x10FFFF`.
* @example
* v.<span class="apidocCodeKeywordSpan">codePoints</span>(&#x27;rain&#x27;);
* // =&#x3e; [114, 97, 105, 110], or
* //    [0x72, 0x61, 0x69, 0x6E]
*
* v.codePoints(&#x27;\uD83D\uDE00 smile&#x27;); // or &#x27;😀 smile&#x27;
* // =&#x3e; [128512, 32, 115, 109, 105, 108, 101], or
* //    [0x1F600, 0x20, 0x73, 0x6D, 0x69, 0x6C, 0x65]
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.conversion_specification" id="apidoc.element.voca.conversion_specification">
        function <span class="apidocSignatureSpan">voca.</span>conversion_specification
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConversionSpecification(properties) {

<span class="apidocCodeCommentSpan">  /**
   * The percent characters from conversion specification.
   *
   * @ignore
   * @name ConversionSpecification#percent
   * @type {string}
   */
</span>  this.percent = properties.percent;

  /**
   *  The sign specifier to force a sign to be used on a number.
   *
   * @ignore
   * @name ConversionSpecification#signSpecifier
   * @type {string}
   */
  this.signSpecifier = properties.signSpecifier;

  /**
   * The padding specifier that says what padding character will be used.
   *
   * @ignore
   * @name ConversionSpecification#paddingSpecifier
   * @type {string}
   */
  this.paddingSpecifier = properties.paddingSpecifier;

  /**
   * The alignment specifier that says if the result should be left-justified or right-justified.
   *
   * @ignore
   * @name ConversionSpecification#alignmentSpecifier
   * @type {string}
   */
  this.alignmentSpecifier = properties.alignmentSpecifier;

  /**
   * The width specifier how many characters this conversion should result in.
   *
   * @ignore
   * @name ConversionSpecification#width
   * @type {number}
   */
  this.width = properties.width;

  /**
   * The precision specifier says how many decimal digits should be displayed for floating-point numbers.
   *
   * @ignore
   * @name ConversionSpecification#precision
   * @type {number}
   */
  this.precision = properties.precision;

  /**
   * The type specifier says what type the argument data should be treated as.
   *
   * @ignore
   * @name ConversionSpecification#typeSpecifier
   * @type {string}
   */
  this.typeSpecifier = properties.typeSpecifier;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.count" id="apidoc.element.voca.count">
        function <span class="apidocSignatureSpan">voca.</span>count
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(subject) {
  return coerceToString(subject).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function count
 * @static
 * @since 1.0.0
 * @memberOf Count
 * @param  {string} [subject=&#x27;&#x27;] The string to count characters.
 * @return {number}              Returns the number of characters in `subject`.
 * @example
 * v.<span class="apidocCodeKeywordSpan">count</span>(&#x27;rain&#x27;);
 * // =&#x3e; 4
 */
function count(subject) {
  return coerceToString(subject).length;
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.countGraphemes" id="apidoc.element.voca.countGraphemes">
        function <span class="apidocSignatureSpan">voca.</span>countGraphemes
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function countGrapheme(subject) {
  return coerceToString(subject).replace(REGEXP_COMBINING_MARKS, &#x27;*&#x27;).replace(REGEXP_SURROGATE_PAIRS, &#x27;*&#x27;).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function  countGraphemes
* @static
* @since 1.0.0
* @memberOf Count
* @param  {string} [subject=&#x27;&#x27;] The string to count graphemes.
* @return {number}              Returns the number of graphemes in `subject`.
* @example
* v.<span class="apidocCodeKeywordSpan">countGraphemes</span>(&#x27;cafe\u0301&#x27;); // or &#x27;café&#x27;
* // =&#x3e; 4
*
* v.countGraphemes(&#x27;\uD835\uDC00\uD835\uDC01&#x27;); // or &#x27;𝐀𝐁&#x27;
* // =&#x3e; 2
*
* v.countGraphemes(&#x27;rain&#x27;);
* // =&#x3e; 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.countSubstrings" id="apidoc.element.voca.countSubstrings">
        function <span class="apidocSignatureSpan">voca.</span>countSubstrings
        <span class="apidocSignatureSpan">(subject, substring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function countSubstrings(subject, substring) {
  var subjectString = coerceToString(subject);
  var substringString = coerceToString(substring);
  var substringLength = substringString.length;
  var count = 0;
  var matchIndex = 0;
  if (subjectString === &#x27;&#x27; || substringString === &#x27;&#x27;) {
    return count;
  }
  do {
    matchIndex = subjectString.indexOf(substringString, matchIndex);
    if (matchIndex !== -1) {
      count++;
      matchIndex += substringLength;
    }
  } while (matchIndex !== -1);
  return count;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Count
 * @param  {string} [subject=&#x27;&#x27;] The string where to count.
 * @param  {string} substring    The substring to be counted.
 * @return {number}              Returns the number of `substring` appearances.
 * @example
 * v.<span class="apidocCodeKeywordSpan">countSubstrings</span>(&#x27;bad boys, bad boys whatcha gonna do?&#x27;, &#x27;boys&#x27
;);
 * // =&#x3e; 2
 *
 * v.countSubstrings(&#x27;every dog has its day&#x27;, &#x27;cat&#x27;);
 * // =&#x3e; 0
 */
function countSubstrings(subject, substring) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.countWhere" id="apidoc.element.voca.countWhere">
        function <span class="apidocSignatureSpan">voca.</span>countWhere
        <span class="apidocSignatureSpan">(subject, predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function countWhere(subject, predicate, context) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27; || typeof predicate !== &#x27;function&#x27;) {
    return 0;
  }
  var predicateWithContext = predicate.bind(context);
  return reduce.call(subjectString, function (countTruthy, character, index) {
    return predicateWithContext(character, index, subjectString) ? countTruthy + 1 : countTruthy;
  }, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Count
* @param  {string}   [subject=&#x27;&#x27;] The string to count characters.
* @param  {Function} predicate    The predicate function invoked on each character with parameters `(character, index, string)`.
* @param  {Object}   [context]    The context to invoke the `predicate`.
* @return {number}                Returns the number of characters for which `predicate` returns truthy.
* @example
* v.<span class="apidocCodeKeywordSpan">countWhere</span>(&#x27;hola!&#x27;, v.isAlpha);
* // =&#x3e; 4
*
* v.countWhere(&#x27;2022&#x27;, function(character, index, str) {
*   return character === &#x27;2&#x27;;
* });
* // =&#x3e; 3
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.countWords" id="apidoc.element.voca.countWords">
        function <span class="apidocSignatureSpan">voca.</span>countWords
        <span class="apidocSignatureSpan">(subject, pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function countWords(subject, pattern, flags) {
  return words(subject, pattern, flags).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Count
* @param {string} [subject=&#x27;&#x27;] The string to split into words.
* @param {string|RegExp} [pattern] The pattern to watch words. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern
, flags)`.
* @param {string} [flags=&#x27;&#x27;] The regular expression flags. Applies when `pattern` is string type.
* @return {number} Returns the number of words.
* @example
* v.<span class="apidocCodeKeywordSpan">countWords</span>(&#x27;gravity can cross dimensions&#x27;);
* // =&#x3e; 4
*
* v.countWords(&#x27;GravityCanCrossDimensions&#x27;);
* // =&#x3e; 4
*
* v.countWords(&#x27;Gravity - can cross dimensions!&#x27;);
* // =&#x3e; 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.decapitalize" id="apidoc.element.voca.decapitalize">
        function <span class="apidocSignatureSpan">voca.</span>decapitalize
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decapitalize(subject) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  return subjectString.substr(0, 1).toLowerCase() + subjectString.substr(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function decapitalize
 * @static
 * @since 1.0.0
 * @memberOf Case
 * @param  {string} [subject=&#x27;&#x27;] The string to decapitalize.
 * @return {string}              Returns the decapitalized string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">decapitalize</span>(&#x27;Sun&#x27;);
 * // =&#x3e; &#x27;sun&#x27;
 *
 * v.decapitalize(&#x27;moon&#x27;);
 * // =&#x3e; &#x27;moon&#x27;
 */
function decapitalize(subject) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.endsWith" id="apidoc.element.voca.endsWith">
        function <span class="apidocSignatureSpan">voca.</span>endsWith
        <span class="apidocSignatureSpan">(subject, end, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endsWith(subject, end, position) {
  if (isNil(end)) {
    return false;
  }
  var subjectString = coerceToString(subject);
  var endString = coerceToString(end);
  if (endString === &#x27;&#x27;) {
    return true;
  }
  position = isNil(position) ? subjectString.length : clipNumber(toInteger(position), 0, subjectString.length);
  position -= endString.length;
  var lastIndex = subjectString.indexOf(endString, position);
  return lastIndex !== -1 &#x26;&#x26; lastIndex === position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @param {string} end The ending string.
* @param {number} [position=subject.length] Search within `subject` as if the string were only `position` long.
* @return {boolean} Returns `true` if `subject` ends with `end` or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">endsWith</span>(&#x27;red alert&#x27;, &#x27;alert&#x27;);
* // =&#x3e; true
*
* v.endsWith(&#x27;metro south&#x27;, &#x27;metro&#x27;);
* // =&#x3e; false
*
* v.endsWith(&#x27;Murphy&#x27;, &#x27;ph&#x27;, 5);
* // =&#x3e; true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.escapeHtml" id="apidoc.element.voca.escapeHtml">
        function <span class="apidocSignatureSpan">voca.</span>escapeHtml
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeHtml(subject) {
  return coerceToString(subject).replace(REGEXP_HTML_SPECIAL_CHARACTERS, replaceSpecialCharacter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function escapeHtml
 * @static
 * @since 1.0.0
 * @memberOf Escape
 * @param {string} [subject=&#x27;&#x27;] The string to escape.
 * @return {string} Returns the escaped string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">escapeHtml</span>(&#x27;&#x3c;p&#x3e;wonderful world&#x3c;/p&#x3e;&#x27;);
 * // =&#x3e; &#x27;&#x26;lt;p&#x26;gt;wonderful world&#x26;lt;/p&#x26;gt;&#x27;
 */
function escapeHtml(subject) {
  return coerceToString(subject).replace(REGEXP_HTML_SPECIAL_CHARACTERS, replaceSpecialCharacter);
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.escapeRegExp" id="apidoc.element.voca.escapeRegExp">
        function <span class="apidocSignatureSpan">voca.</span>escapeRegExp
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeRegExp(subject) {
  return coerceToString(subject).replace(REGEXP_SPECIAL_CHARACTERS, &#x27;\\$&#x26;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function escapeRegExp
 * @static
 * @since 1.0.0
 * @memberOf Escape
 * @param {string} [subject=&#x27;&#x27;] The string to escape.
 * @return {string} Returns the escaped string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">escapeRegExp</span>(&#x27;(hours)[minutes]{seconds}&#x27;);
 * // =&#x3e; &#x27;\(hours\)\[minutes\]\{seconds\}&#x27;
 */
function escapeRegExp(subject) {
  return coerceToString(subject).replace(REGEXP_SPECIAL_CHARACTERS, &#x27;\\$&#x26;&#x27;);
}

var unescapeCharactersMap = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.first" id="apidoc.element.voca.first">
        function <span class="apidocSignatureSpan">voca.</span>first
        <span class="apidocSignatureSpan">(subject, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function first(subject, length) {
  var subjectString = coerceToString(subject);
  var lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
  if (subjectString.length &#x3c;= lengthInt) {
    return subjectString;
  }
  return subjectString.substr(0, lengthInt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @static
* @since 1.0.0
* @memberOf Chop
* @param  {string} [subject=&#x27;&#x27;] The string to extract from.
* @param  {int}    [length=1]   The number of characters to extract.
* @return {string}              Returns the first characters string.
* @example
* v.<span class="apidocCodeKeywordSpan">first</span>(&#x27;helicopter&#x27;);
* // =&#x3e; &#x27;h&#x27;
*
* v.first(&#x27;vehicle&#x27;, 2);
* // =&#x3e; &#x27;ve&#x27;
*
* v.first(&#x27;car&#x27;, 5);
* // =&#x3e; &#x27;car&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.graphemeAt" id="apidoc.element.voca.graphemeAt">
        function <span class="apidocSignatureSpan">voca.</span>graphemeAt
        <span class="apidocSignatureSpan">(subject, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function graphemeAt(subject, position) {
  var subjectString = coerceToString(subject);
  var positionNumber = coerceToNumber(position);
  var graphemeMatch = void 0;
  var graphemeMatchIndex = 0;
  positionNumber = nanDefault(positionNumber, 0);
  while ((graphemeMatch = REGEXP_UNICODE_CHARACTER.exec(subjectString)) !== null) {
    if (graphemeMatchIndex === positionNumber) {
      REGEXP_UNICODE_CHARACTER.lastIndex = 0;
      return graphemeMatch[0];
    }
    graphemeMatchIndex++;
  }
  return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Chop
 * @param  {string} [subject=&#x27;&#x27;] The string to extract from.
 * @param  {number} position The position to get the grapheme.
 * @return {string} Returns the grapheme at specified position.
 * @example
 * v.<span class="apidocCodeKeywordSpan">graphemeAt</span>(&#x27;\uD835\uDC00\uD835\uDC01&#x27;, 0); // or &#x27;𝐀𝐁&#x27;
 * // =&#x3e; &#x27;A&#x27;
 *
 * v.graphemeAt(&#x27;cafe\u0301&#x27;, 3); // or &#x27;café&#x27;
 * // =&#x3e; &#x27;é&#x27;
 */
function graphemeAt(subject, position) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.graphemes" id="apidoc.element.voca.graphemes">
        function <span class="apidocSignatureSpan">voca.</span>graphemes
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function graphemes(subject) {
  var subjectString = coerceToString(subject);
  return nilDefault(subjectString.match(REGEXP_UNICODE_CHARACTER), []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function graphemes
* @static
* @since 1.0.0
* @memberOf Split
* @param {string} [subject=&#x27;&#x27;] The string to split into characters.
* @return {Array} Returns the array of graphemes.
* @example
* v.<span class="apidocCodeKeywordSpan">graphemes</span>(&#x27;\uD835\uDC00\uD835\uDC01&#x27;); // or &#x27;𝐀𝐁&#x27;
* // =&#x3e; [&#x27;\uD835\uDC00&#x27;, &#x27;\uD835\uDC01&#x27;], or
* //    [&#x27;𝐀&#x27;, &#x27;𝐁&#x27;]
*
* v.graphemes(&#x27;cafe\u0301&#x27;); // or &#x27;café&#x27;
* // =&#x3e; [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;f&#x27;, &#x27;e\u0301&#x27;], or
* //    [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;f&#x27;, &#x27;é&#x27;]
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.includes" id="apidoc.element.voca.includes">
        function <span class="apidocSignatureSpan">voca.</span>includes
        <span class="apidocSignatureSpan">(subject, search, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function includes(subject, search, position) {
  var subjectString = coerceToString(subject);
  var searchString = toString(search);
  if (searchString === null) {
    return false;
  }
  if (searchString === &#x27;&#x27;) {
    return true;
  }
  position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);
  return subjectString.indexOf(searchString, position) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @since 1.0.0
 * @memberOf Query
 * @param {string} [subject=&#x27;&#x27;] The string where to search.
 * @param {string} search The string to search.
 * @param {number} [position=0] The position to start searching.
 * @return {boolean} Returns `true` if `subject` includes `search` or `false` otherwise.
 * @example
 * v.<span class="apidocCodeKeywordSpan">includes</span>(&#x27;starship&#x27;, &#x27;star&#x27;);
 * // =&#x3e; true
 *
 * v.includes(&#x27;galaxy&#x27;, &#x27;g&#x27;, 1);
 * // =&#x3e; false
 */
function includes(subject, search, position) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.indexOf" id="apidoc.element.voca.indexOf">
        function <span class="apidocSignatureSpan">voca.</span>indexOf
        <span class="apidocSignatureSpan">(subject, search, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexOf(subject, search, fromIndex) {
  var subjectString = coerceToString(subject);
  return subjectString.indexOf(search, fromIndex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
function titleCase(subject, ignoreWords) {
 var subjectString = coerceToString(subject);
 var ignoreWordsArray = Array.isArray(ignoreWords) ? ignoreWords : [];
 var wordsRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
 return subjectString.replace(wordsRegExp, function (word) {
   var lowerCaseWord = word.toLowerCase();
   return ignoreWordsArray.<span class="apidocCodeKeywordSpan">indexOf</span>(lowerCaseWord) !== -1 ? lowerCaseWord : capitalize
(lowerCaseWord, true);
 });
}

/**
* Clip the number to interval `downLimit` to `upLimit`.
*
* @ignore
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.insert" id="apidoc.element.voca.insert">
        function <span class="apidocSignatureSpan">voca.</span>insert
        <span class="apidocSignatureSpan">(subject, toInsert, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insert(subject, toInsert, position) {
  var subjectString = coerceToString(subject);
  var toInsertString = coerceToString(toInsert);
  var positionNumber = coerceToNumber(position);
  if (positionNumber &#x3c; 0 || positionNumber &#x3e; subjectString.length || toInsertString === &#x27;&#x27;) {
    return subjectString;
  }
  return subjectString.slice(0, positionNumber) + toInsertString + subjectString.slice(positionNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @since 1.0.0
 * @memberOf Manipulate
 * @param {string} [subject=&#x27;&#x27;] The string where to insert.
 * @param {string} [toInsert=&#x27;&#x27;] The string to be inserted.
 * @param {number} [position=0] The position to insert.
 * @return {string} Returns the string after insertion.
 * @example
 * v.<span class="apidocCodeKeywordSpan">insert</span>(&#x27;ct&#x27;, &#x27;a&#x27;, 1);
 * // =&#x3e; &#x27;cat&#x27;
 *
 * v.insert(&#x27;sunny&#x27;, &#x27; day&#x27;, 5);
 * // =&#x3e; &#x27;sunny day&#x27;
 */
function insert(subject, toInsert, position) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isAlpha" id="apidoc.element.voca.isAlpha">
        function <span class="apidocSignatureSpan">voca.</span>isAlpha
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAlpha(subject) {
  var subjectString = coerceToString(subject);
  return REGEXP_ALPHA.test(subjectString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function isAlpha
* @static
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @return {boolean} Returns `true` if `subject` contains only alpha characters or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">isAlpha</span>(&#x27;bart&#x27;);
* // =&#x3e; true
*
* v.isAlpha(&#x27;lisa!&#x27;);
* // =&#x3e; false
*
* v.isAlpha(&#x27;lisa and bart&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isAlphaDigit" id="apidoc.element.voca.isAlphaDigit">
        function <span class="apidocSignatureSpan">voca.</span>isAlphaDigit
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAlphaDigit(subject) {
  var subjectString = coerceToString(subject);
  return REGEXP_ALPHA_DIGIT.test(subjectString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function isAlphaDigit
* @static
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @return {boolean} Returns `true` if `subject` contains only alpha and digit characters or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">isAlphaDigit</span>(&#x27;year2020&#x27;);
* // =&#x3e; true
*
* v.isAlphaDigit(&#x27;1448&#x27;);
* // =&#x3e; true
*
* v.isAlphaDigit(&#x27;40-20&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isBlank" id="apidoc.element.voca.isBlank">
        function <span class="apidocSignatureSpan">voca.</span>isBlank
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBlank(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.trim().length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function isBlank
* @static
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @return {boolean} Returns `true` if `subject` is empty or contains only whitespaces or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">isBlank</span>(&#x27;&#x27;);
* // =&#x3e; true
*
* v.isBlank(&#x27;  &#x27;);
* // =&#x3e; true
*
* v.isBlank(&#x27;World&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isDigit" id="apidoc.element.voca.isDigit">
        function <span class="apidocSignatureSpan">voca.</span>isDigit
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDigit(subject) {
  var subjectString = coerceToString(subject);
  return REGEXP_DIGIT.test(subjectString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function isDigit
* @static
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @return {boolean} Returns `true` if `subject` contains only digit characters or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">isDigit</span>(&#x27;35&#x27;);
* // =&#x3e; true
*
* v.isDigit(&#x27;1.5&#x27;);
* // =&#x3e; false
*
* v.isDigit(&#x27;ten&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isEmpty" id="apidoc.element.voca.isEmpty">
        function <span class="apidocSignatureSpan">voca.</span>isEmpty
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEmpty(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function isEmpty
* @static
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @return {boolean} Returns `true` if `subject` is empty or `false` otherwise
* @example
* v.<span class="apidocCodeKeywordSpan">isEmpty</span>(&#x27;&#x27;);
* // =&#x3e; true
*
* v.isEmpty(&#x27;  &#x27;);
* // =&#x3e; false
*
* v.isEmpty(&#x27;sun&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isLowerCase" id="apidoc.element.voca.isLowerCase">
        function <span class="apidocSignatureSpan">voca.</span>isLowerCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLowerCase(subject) {
  var valueString = coerceToString(subject);
  return isAlpha(valueString) &#x26;&#x26; valueString.toLowerCase() === valueString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function isLowerCase
* @static
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @return {boolean} Returns `true` if `subject` is lower case or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">isLowerCase</span>(&#x27;motorcycle&#x27;);
* // =&#x3e; true
*
* v.isLowerCase(&#x27;John&#x27;);
* // =&#x3e; false
*
* v.isLowerCase(&#x27;T1000&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isNumeric" id="apidoc.element.voca.isNumeric">
        function <span class="apidocSignatureSpan">voca.</span>isNumeric
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumeric(subject) {
  var valueNumeric = typeof subject === &#x27;object&#x27; &#x26;&#x26; !isNil(subject) ? Number(subject) : subject;
  return (typeof valueNumeric === &#x27;number&#x27; || typeof valueNumeric === &#x27;string&#x27;) &#x26;&#x26; !isNaN(valueNumeric - parseFloat(valueNumeric
));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function isNumeric
* @static
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @return {boolean} Returns `true` if `subject` is numeric or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">isNumeric</span>(&#x27;350&#x27;);
* // =&#x3e; true
*
* v.isNumeric(&#x27;-20.5&#x27;);
* // =&#x3e; true
*
* v.isNumeric(&#x27;1.5E+2&#x27;);
* // =&#x3e; true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isString" id="apidoc.element.voca.isString">
        function <span class="apidocSignatureSpan">voca.</span>isString
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(subject) {
  return typeof subject === &#x27;string&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function isString
 * @static
 * @since 1.0.0
 * @memberOf Query
 * @param {string} subject The value to verify.
 * @return {boolean} Returns `true` if `subject` is string primitive type or `false` otherwise.
 * @example
 * v.<span class="apidocCodeKeywordSpan">isString</span>(&#x27;vacation&#x27;);
 * // =&#x3e; true
 *
 * v.isString(560);
 * // =&#x3e; false
 */
function isString(subject) {
return typeof subject === &#x27;string&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.isUpperCase" id="apidoc.element.voca.isUpperCase">
        function <span class="apidocSignatureSpan">voca.</span>isUpperCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUpperCase(subject) {
  var subjectString = coerceToString(subject);
  return isAlpha(subjectString) &#x26;&#x26; subjectString.toUpperCase() === subjectString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function isUpperCase
 * @static
 * @since 1.0.0
 * @memberOf Query
 * @param {string} [subject=&#x27;&#x27;] The string to verify.
 * @return {boolean} Returns `true` if `subject` is upper case or `false` otherwise.
 * @example
 * v.<span class="apidocCodeKeywordSpan">isUpperCase</span>(&#x27;ACDC&#x27;);
 * // =&#x3e; true
 *
 * v.isUpperCase(&#x27;Morning&#x27;);
 * // =&#x3e; false
 */
function isUpperCase(subject) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.kebabCase" id="apidoc.element.voca.kebabCase">
        function <span class="apidocSignatureSpan">voca.</span>kebabCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kebabCase(subject) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  return words(subjectString).map(lowerCase).join(&#x27;-&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### ES2015 modules

Voca is compatible with ES2015 modules to import the entire library:

```javascript
import voca from &#x27;voca&#x27;;
v.<span class="apidocCodeKeywordSpan">kebabCase</span>(&#x27;goodbye blue sky&#x27;); // =&#x3e; &#x27;goodbye-blue-sky&#x27;
```

Or import individual functions:

```javascript
import last from &#x27;voca/last&#x27;;
last(&#x27;sun rises&#x27;, 5); // =&#x3e; &#x27;rises&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.last" id="apidoc.element.voca.last">
        function <span class="apidocSignatureSpan">voca.</span>last
        <span class="apidocSignatureSpan">(subject, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function last(subject, length) {
  var subjectString = coerceToString(subject);
  var lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
  if (subjectString.length &#x3c;= lengthInt) {
    return subjectString;
  }
  return subjectString.substr(subjectString.length - lengthInt, lengthInt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;script src=&#x22;voca.js&#x22; type=&#x22;text/javascript&#x22;&#x3e;&#x3c;/script&#x3e;
```

Then a global variable `v` is exposed for the entire library:

```html
&#x3c;script type=&#x22;text/javascript&#x22;&#x3e;
  v.<span class="apidocCodeKeywordSpan">last</span>(&#x27;wonderful world&#x27;, 5); // =&#x3e; &#x27;world&#x27;
&#x3c;/script&#x3e;
```

## Bug reports

For bug reports, documentation typos or feature requests feel free to create an [issue](https://github.com/panzerdp/voca/issues).
Please make sure that the same problem wasn&#x27;t reported already.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.lastIndexOf" id="apidoc.element.voca.lastIndexOf">
        function <span class="apidocSignatureSpan">voca.</span>lastIndexOf
        <span class="apidocSignatureSpan">(subject, search, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lastIndexOf(subject, search, fromIndex) {
  var subjectString = coerceToString(subject);
  return subjectString.lastIndexOf(search, fromIndex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @since 1.0.0
 * @memberOf Index
 * @param {string} [subject=&#x27;&#x27;] The string where to search.
 * @param {string} search The string to search.
 * @param {number} [fromIndex=subject.length - 1] The index to start searching backward in the string.
 * @return {number} Returns the last occurrence index or `-1` if not found.
 * @example
 * v.<span class="apidocCodeKeywordSpan">lastIndexOf</span>(&#x27;morning&#x27;, &#x27;n&#x27;);
 * // =&#x3e; 5
 *
 * v.lastIndexOf(&#x27;evening&#x27;, &#x27;o&#x27;);
 * // =&#x3e; -1
 */
function lastIndexOf(subject, search, fromIndex) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.latinise" id="apidoc.element.voca.latinise">
        function <span class="apidocSignatureSpan">voca.</span>latinise
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function latinise(subject) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  return subjectString.replace(REGEXP_NON_LATIN, getLatinCharacter).replace(REGEXP_COMBINING_MARKS, removeCombiningMarks);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function latinise
* @static
* @since 1.0.0
* @memberOf Manipulate
* @param {string} [subject=&#x27;&#x27;] The string to latinise.
* @return {string} Returns the latinised string.
* @example
* v.<span class="apidocCodeKeywordSpan">latinise</span>(&#x27;cafe\u0301&#x27;); // or &#x27;café&#x27;
* // =&#x3e; &#x27;cafe&#x27;
*
* v.latinise(&#x27;août décembre&#x27;);
* // =&#x3e; &#x27;aout decembre&#x27;
*
* v.latinise(&#x27;как прекрасен этот мир&#x27;);
* // =&#x3e; &#x27;kak prekrasen etot mir&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.lowerCase" id="apidoc.element.voca.lowerCase">
        function <span class="apidocSignatureSpan">voca.</span>lowerCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lowerCase(subject) {
  var subjectString = coerceToString(subject, &#x27;&#x27;);
  return subjectString.toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function lowerCase
 * @static
 * @since 1.0.0
 * @memberOf Case
 * @param  {string} [subject=&#x27;&#x27;] The string to convert to lower case.
 * @return {string}              Returns the lower case string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">lowerCase</span>(&#x27;Green&#x27;);
 * // =&#x3e; &#x27;green&#x27;
 *
 * v.lowerCase(&#x27;BLUE&#x27;);
 * // =&#x3e; &#x27;blue&#x27;
 */
function lowerCase(subject) {
var subjectString = coerceToString(subject, &#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.matches" id="apidoc.element.voca.matches">
        function <span class="apidocSignatureSpan">voca.</span>matches
        <span class="apidocSignatureSpan">(subject, pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matches(subject, pattern, flags) {
  var subjectString = coerceToString(subject);
  var flagsString = coerceToString(flags);
  var patternString = void 0;
  if (!(pattern instanceof RegExp)) {
    patternString = toString(pattern);
    if (patternString === null) {
      return false;
    }
    pattern = new RegExp(patternString, flagsString);
  }
  return pattern.test(subjectString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @param {RegExp|string} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern, flags
)`.
* @param {string} [flags=&#x27;&#x27;] The regular expression flags. Applies when `pattern` is string type.
* @return {boolean} Returns `true` if `subject` matches `pattern` or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">matches</span>(&#x27;pluto&#x27;, /plu.{2}/);
* // =&#x3e; true
*
* v.matches(&#x27;sun&#x27;, &#x27;S&#x27;, &#x27;i&#x27;);
* // =&#x3e; true
*
* v.matches(&#x27;apollo 11&#x27;, &#x27;\\d{3}&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.noConflict" id="apidoc.element.voca.noConflict">
        function <span class="apidocSignatureSpan">voca.</span>noConflict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noConflict() {
  if (this === globalObject.v) {
    globalObject.v = previousV;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @function noConflict
 * @static
 * @since 1.0.0
 * @memberOf Util
 * @return {Object} Returns Voca library instance.
 * @example
 * var voca = v.<span class="apidocCodeKeywordSpan">noConflict</span>();
 * voca.isAlpha(&#x27;Hello&#x27;);
 * // =&#x3e; true
 */
function noConflict() {
if (this === globalObject.v) {
  globalObject.v = previousV;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.pad" id="apidoc.element.voca.pad">
        function <span class="apidocSignatureSpan">voca.</span>pad
        <span class="apidocSignatureSpan">(subject, length, pad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad(subject, length, pad) {
  var subjectString = coerceToString(subject);
  var lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
  var padString = coerceToString(pad, &#x27; &#x27;);
  if (lengthInt &#x3c;= subjectString.length) {
    return subjectString;
  }
  var paddingLength = lengthInt - subjectString.length;
  var paddingSideLength = toInteger(paddingLength / 2);
  var paddingSideRemainingLength = paddingLength % 2;
  return buildPadding(padString, paddingSideLength) + subjectString + buildPadding(padString, paddingSideLength + paddingSideRemainingLength
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Manipulate
* @param {string} [subject=&#x27;&#x27;] The string to pad.
* @param {int} [length=0] The length to pad the string. No changes are made if `length` is less than `subject.length`.
* @param {string} [pad=&#x27; &#x27;] The string to be used for padding.
* @return {string} Returns the padded string.
* @example
* v.<span class="apidocCodeKeywordSpan">pad</span>(&#x27;dog&#x27;, 5);
* // =&#x3e; &#x27; dog &#x27;
*
* v.pad(&#x27;bird&#x27;, 6, &#x27;-&#x27;);
* // =&#x3e; &#x27;-bird-&#x27;
*
* v.pad(&#x27;cat&#x27;, 6, &#x27;-=&#x27;);
* // =&#x3e; &#x27;-cat-=&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.padLeft" id="apidoc.element.voca.padLeft">
        function <span class="apidocSignatureSpan">voca.</span>padLeft
        <span class="apidocSignatureSpan">(subject, length, pad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function padLeft(subject, length, pad) {
  var subjectString = coerceToString(subject);
  var lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
  var padString = coerceToString(pad, &#x27; &#x27;);
  if (lengthInt &#x3c;= subjectString.length) {
    return subjectString;
  }
  return buildPadding(padString, lengthInt - subjectString.length) + subjectString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Manipulate
* @param {string} [subject=&#x27;&#x27;] The string to pad.
* @param {int} [length=0] The length to left pad the string. No changes are made if `length` is less than `subject.length`.
* @param {string} [pad=&#x27; &#x27;] The string to be used for padding.
* @return {string} Returns the left padded string.
* @example
* v.<span class="apidocCodeKeywordSpan">padLeft</span>(&#x27;dog&#x27;, 5);
* // =&#x3e; &#x27;  dog&#x27;
*
* v.padLeft(&#x27;bird&#x27;, 6, &#x27;-&#x27;);
* // =&#x3e; &#x27;--bird&#x27;
*
* v.padLeft(&#x27;cat&#x27;, 6, &#x27;-=&#x27;);
* // =&#x3e; &#x27;-=-cat&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.padRight" id="apidoc.element.voca.padRight">
        function <span class="apidocSignatureSpan">voca.</span>padRight
        <span class="apidocSignatureSpan">(subject, length, pad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function padRight(subject, length, pad) {
  var subjectString = coerceToString(subject);
  var lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
  var padString = coerceToString(pad, &#x27; &#x27;);
  if (lengthInt &#x3c;= subjectString.length) {
    return subjectString;
  }
  return subjectString + buildPadding(padString, lengthInt - subjectString.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Manipulate
* @param {string} [subject=&#x27;&#x27;] The string to pad.
* @param {int} [length=0] The length to right pad the string. No changes are made if `length` is less than `subject.length`.
* @param {string} [pad=&#x27; &#x27;] The string to be used for padding.
* @return {string} Returns the right padded string.
* @example
* v.<span class="apidocCodeKeywordSpan">padRight</span>(&#x27;dog&#x27;, 5);
* // =&#x3e; &#x27;dog  &#x27;
*
* v.padRight(&#x27;bird&#x27;, 6, &#x27;-&#x27;);
* // =&#x3e; &#x27;bird--&#x27;
*
* v.padRight(&#x27;cat&#x27;, 6, &#x27;-=&#x27;);
* // =&#x3e; &#x27;cat-=-&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.prune" id="apidoc.element.voca.prune">
        function <span class="apidocSignatureSpan">voca.</span>prune
        <span class="apidocSignatureSpan">(subject, length, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prune(subject, length, end) {
  var subjectString = coerceToString(subject);
  var lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
  var endString = coerceToString(end, &#x27;...&#x27;);
  if (lengthInt &#x3e;= subjectString.length) {
    return subjectString;
  }
  var pattern = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
  var truncatedLength = 0;
  subjectString.replace(pattern, function (word, offset) {
    var wordInsertLength = offset + word.length;
    if (wordInsertLength &#x3c;= lengthInt - endString.length) {
      truncatedLength = wordInsertLength;
    }
  });
  return subjectString.substr(0, truncatedLength) + endString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Chop
* @param  {string} [subject=&#x27;&#x27;] The string to prune.
* @param  {int}    length       The length to prune the string.
* @param  {string} [end=&#x27;...&#x27;]  The string to be added at the end.
* @return {string}              Returns the pruned string.
* @example
* v.<span class="apidocCodeKeywordSpan">prune</span>(&#x27;Once upon a time&#x27;, 7);
* // =&#x3e; &#x27;Once...&#x27;
*
* v.prune(&#x27;Good day, Little Red Riding Hood&#x27;, 16, &#x27; (more)&#x27;);
* // =&#x3e; &#x27;Good day (more)&#x27;
*
* v.prune(&#x27;Once upon&#x27;, 10);
* // =&#x3e; &#x27;Once upon&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.repeat" id="apidoc.element.voca.repeat">
        function <span class="apidocSignatureSpan">voca.</span>repeat
        <span class="apidocSignatureSpan">(subject, times)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repeat(subject, times) {
  var subjectString = coerceToString(subject);
  var timesInt = isNil(times) ? 1 : clipNumber(toInteger(times), 0, MAX_SAFE_INTEGER);
  var repeatString = &#x27;&#x27;;
  while (timesInt) {
    if (timesInt &#x26; 1) {
      repeatString += subjectString;
    }
    if (timesInt &#x3e; 1) {
      subjectString += subjectString;
    }
    timesInt &#x3e;&#x3e;= 1;
  }
  return repeatString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Manipulate
 * @param {string} [subject=&#x27;&#x27;] The string to repeat.
 * @param {number} [times=1] The number of times to repeat.
 * @return {string} Returns the repeated string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">repeat</span>(&#x27;w&#x27;, 3);
 * // =&#x3e; &#x27;www&#x27;
 *
 * v.repeat(&#x27;world&#x27;, 0);
 * // =&#x3e; &#x27;&#x27;
 */
function repeat(subject, times) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.replace" id="apidoc.element.voca.replace">
        function <span class="apidocSignatureSpan">voca.</span>replace
        <span class="apidocSignatureSpan">(subject, pattern, replacement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(subject, pattern, replacement) {
  var subjectString = coerceToString(subject);
  return subjectString.replace(pattern, replacement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* v.titleCase(&#x27;another brick in the wall&#x27;, [&#x27;in&#x27;, &#x27;the&#x27;]);
* // =&#x3e; &#x27;Another Brick in the Wall&#x27;
*/
function titleCase(subject, ignoreWords) {
 var subjectString = coerceToString(subject);
 var ignoreWordsArray = Array.isArray(ignoreWords) ? ignoreWords : [];
 var wordsRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
 return subjectString.<span class="apidocCodeKeywordSpan">replace</span>(wordsRegExp, function (word) {
   var lowerCaseWord = word.toLowerCase();
   return ignoreWordsArray.indexOf(lowerCaseWord) !== -1 ? lowerCaseWord : capitalize(lowerCaseWord, true);
 });
}

/**
* Clip the number to interval `downLimit` to `upLimit`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.replaceAll" id="apidoc.element.voca.replaceAll">
        function <span class="apidocSignatureSpan">voca.</span>replaceAll
        <span class="apidocSignatureSpan">(subject, pattern, replacement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceAll(subject, pattern, replacement) {
  var subjectString = coerceToString(subject);
  var regExp = pattern;
  if (!(pattern instanceof RegExp)) {
    regExp = new RegExp(escapeRegExp(pattern), &#x27;g&#x27;);
  } else if (!pattern.global) {
    regExp = appendFlagToRegExp(pattern, &#x27;g&#x27;);
  }
  return subjectString.replace(regExp, replacement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @memberOf Manipulate
 * @param {string} [subject=&#x27;&#x27;] The string to verify.
 * @param {string|RegExp} pattern The pattern which match is replaced. If `pattern` is a string, a simple string match is evaluated
.
 * All matches are replaced.
 * @param {string|Function} replacement The string or function which invocation result replaces `pattern` match.
 * @return {string} Returns the replacement result.
 * @example
 * v.<span class="apidocCodeKeywordSpan">replaceAll</span>(&#x27;good morning&#x27;, &#x27;o&#x27;, &#x27;*&#x27;);
 * // =&#x3e; &#x27;g**d m*rning&#x27;
 * v.replaceAll(&#x27;evening&#x27;, /n/, &#x27;s&#x27;);
 * // =&#x3e; &#x27;evesisg&#x27;
 *
 */
function replaceAll(subject, pattern, replacement) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.reverse" id="apidoc.element.voca.reverse">
        function <span class="apidocSignatureSpan">voca.</span>reverse
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reverse(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function reverse
 * @static
 * @since 1.0.0
 * @memberOf Manipulate
 * @param {string} [subject=&#x27;&#x27;] The string to reverse.
 * @return {string} Returns the reversed string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">reverse</span>(&#x27;winter&#x27;);
 * // =&#x3e; &#x27;retniw&#x27;
 */
function reverse(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.reverseGrapheme" id="apidoc.element.voca.reverseGrapheme">
        function <span class="apidocSignatureSpan">voca.</span>reverseGrapheme
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reverseGrapheme(subject) {
  var subjectString = coerceToString(subject);
<span class="apidocCodeCommentSpan">  /**
   * @see https://github.com/mathiasbynens/esrever
   */
</span>  subjectString = subjectString.replace(REGEXP_COMBINING_MARKS, function ($0, $1, $2) {
    return reverseGrapheme($2) + $1;
  }).replace(REGEXP_SURROGATE_PAIRS, &#x27;$2$1&#x27;);
  var reversedString = &#x27;&#x27;;
  var index = subjectString.length;
  while (index--) {
    reversedString += subjectString.charAt(index);
  }
  return reversedString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function reverseGrapheme
 * @static
 * @since 1.0.0
 * @memberOf Manipulate
 * @param {string} [subject=&#x27;&#x27;] The string to reverse.
 * @return {string} Returns the reversed string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">reverseGrapheme</span>(&#x27;summer&#x27;);
 * // =&#x3e; &#x27;remmus&#x27;
 *
 * v.reverseGrapheme(&#x27;𝌆 bar mañana mañana&#x27;);
 * // =&#x3e; &#x27;anañam anañam rab 𝌆&#x27;
 */
function reverseGrapheme(subject) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.search" id="apidoc.element.voca.search">
        function <span class="apidocSignatureSpan">voca.</span>search
        <span class="apidocSignatureSpan">(subject, pattern, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function search(subject, pattern, fromIndex) {
  var subjectString = coerceToString(subject);
  var fromIndexNumber = isNil(fromIndex) ? 0 : clipNumber(toInteger(fromIndex), 0, subjectString.length);
  var matchIndex = subjectString.substr(fromIndexNumber).search(pattern);
  if (matchIndex !== -1 &#x26;&#x26; !isNaN(fromIndexNumber)) {
    matchIndex += fromIndexNumber;
  }
  return matchIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @since 1.0.0
 * @memberOf Index
 * @param {string} [subject=&#x27;&#x27;] The string where to search.
 * @param {string|RegExp} pattern The pattern to match. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern)`.
 * @param {number} [fromIndex=0] The index to start searching.
 * @return {number} Returns the first match index or `-1` if not found.
 * @example
 * v.<span class="apidocCodeKeywordSpan">search</span>(&#x27;morning&#x27;, /rn/);
 * // =&#x3e; 2
 *
 * v.search(&#x27;evening&#x27;, &#x27;/\d/&#x27;);
 * // =&#x3e; -1
 */
function search(subject, pattern, fromIndex) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.slice" id="apidoc.element.voca.slice">
        function <span class="apidocSignatureSpan">voca.</span>slice
        <span class="apidocSignatureSpan">(subject, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function slice(subject, start, end) {
  return coerceToString(subject).slice(start, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @static
* @since 1.0.0
* @memberOf Chop
* @param  {string} [subject=&#x27;&#x27;]         The string to extract from.
* @param  {number} start                The position to start extraction. If negative use `subject.length + start`.
* @param  {number} [end=subject.length] The position to end extraction. If negative use `subject.length + end`.
* @return {string}                      Returns the extracted string.
* @note Uses native `String.prototype.<span class="apidocCodeKeywordSpan">slice</span>()`
* @example
* v.slice(&#x27;miami&#x27;, 1);
* // =&#x3e; &#x27;iami&#x27;
*
* v.slice(&#x27;florida&#x27;, -4);
* // =&#x3e; &#x27;rida&#x27;
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.slugify" id="apidoc.element.voca.slugify">
        function <span class="apidocSignatureSpan">voca.</span>slugify
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function slugify(subject) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  var cleanSubjectString = latinise(subjectString).replace(REGEXP_NON_LATIN, &#x27;-&#x27;);
  return kebabCase(cleanSubjectString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[![npm package](https://img.shields.io/npm/v/voca.svg)](https://www.npmjs.com/package/voca)

Voca is a JavaScript library for manipulating strings. [https://vocajs.com][voca]

```javascript
v.camelCase(&#x27;bird flight&#x27;);              // =&#x3e; &#x27;birdFlight&#x27;
v.sprintf(&#x27;%s costs $%.2f&#x27;, &#x27;Tea&#x27;, 1.5); // =&#x3e; &#x27;Tea costs $1.50&#x27;
v.<span class="apidocCodeKeywordSpan">slugify</span>(&#x27;What a wonderful world&#x27;);     // =&#x3e; &#x27;what-a-wonderful-
world&#x27;
```

The Voca library offers helpful functions to make string manipulations comfortable: *change case, trim, pad, slugify,
latinise, sprintf&#x27;y, truncate, escape* and much more.  The *modular design* allows to load the entire library, or
individual functions to minimize the application builds. The library is *fully tested*, *well documented* and *long-term supported
*.

## Features
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.snakeCase" id="apidoc.element.voca.snakeCase">
        function <span class="apidocSignatureSpan">voca.</span>snakeCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function snakeCase(subject) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  return words(subjectString).map(lowerCase).join(&#x27;_&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @function snakeCase
* @static
* @since 1.0.0
* @memberOf Case
* @param  {string} [subject=&#x27;&#x27;] The string to convert to snake case.
* @return {string}              Returns the snake case string.
* @example
* v.<span class="apidocCodeKeywordSpan">snakeCase</span>(&#x27;learning to fly&#x27;);
* // =&#x3e; &#x27;learning_to_fly&#x27;
*
* v.snakeCase(&#x27;LearningToFly&#x27;);
* // =&#x3e; &#x27;learning_to_fly&#x27;
*
* v.snakeCase(&#x27;-Learning-To-Fly-&#x27;);
* // =&#x3e; &#x27;learning_to_fly&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.splice" id="apidoc.element.voca.splice">
        function <span class="apidocSignatureSpan">voca.</span>splice
        <span class="apidocSignatureSpan">(subject, start, deleteCount, toAdd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splice(subject, start, deleteCount, toAdd) {
  var subjectString = coerceToString(subject);
  var toAddString = coerceToString(toAdd);
  var startPosition = coerceToNumber(start);
  if (startPosition &#x3c; 0) {
    startPosition = subjectString.length + startPosition;
    if (startPosition &#x3c; 0) {
      startPosition = 0;
    }
  } else if (startPosition &#x3e; subjectString.length) {
    startPosition = subjectString.length;
  }
  var deleteCountNumber = coerceToNumber(deleteCount, subjectString.length - startPosition);
  if (deleteCountNumber &#x3c; 0) {
    deleteCountNumber = 0;
  }
  return subjectString.slice(0, startPosition) + toAddString + subjectString.slice(startPosition + deleteCountNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {string} [subject=&#x27;&#x27;] The string where to insert.
* @param {string} start The position to start changing the string. For a negative position will start from the end of
* the string.
* @param {number} [deleteCount=subject.length-start] The number of characters to delete from string.
* @param {string} [toAdd=&#x27;&#x27;] The string to be added instead of deleted characters.
* @return {string} Returns the modified string.
* @example
* v.<span class="apidocCodeKeywordSpan">splice</span>(&#x27;new year&#x27;, 0, 4);
* // =&#x3e; &#x27;year&#x27;
*
* v.splice(&#x27;new year&#x27;, 0, 3, &#x27;happy&#x27;);
* // =&#x3e; &#x27;happy year&#x27;
*
* v.splice(&#x27;new year&#x27;, -4, 4, &#x27;day&#x27;);
* // =&#x3e; &#x27;new day&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.split" id="apidoc.element.voca.split">
        function <span class="apidocSignatureSpan">voca.</span>split
        <span class="apidocSignatureSpan">(subject, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function split(subject, separator, limit) {
  var subjectString = coerceToString(subject);
  return subjectString.split(separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // =&#x3e; &#x27;lEAGE OF sHADOWS&#x27;
 *
 * v.swapCase(&#x27;2 Bees&#x27;);
 * // =&#x3e; &#x27;2 bEES&#x27;
 */
function swapCase(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.<span class="apidocCodeKeywordSpan">split</span>(&#x27;&#x27;).reduce(swapAndConcat, &#x27;&#x27;);
}

function swapAndConcat(swapped, character) {
  var lowerCase = character.toLowerCase();
  var upperCase = character.toUpperCase();
  return swapped + (character === lowerCase ? upperCase : lowerCase);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.sprintf" id="apidoc.element.voca.sprintf">
        function <span class="apidocSignatureSpan">voca.</span>sprintf
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sprintf(format) {
  var formatString = coerceToString(format);
  if (formatString === &#x27;&#x27;) {
    return formatString;
  }

  for (var _len = arguments.length, replacements = Array(_len &#x3e; 1 ? _len - 1 : 0), _key = 1; _key &#x3c; _len; _key++) {
    replacements[_key - 1] = arguments[_key];
  }

  var boundReplacementMatch = match.bind(undefined, new ReplacementIndex(), replacements);
  return formatString.replace(REGEXP_CONVERSION_SPECIFICATION, boundReplacementMatch);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[![code coverage](https://img.shields.io/codecov/c/github/panzerdp/voca.svg)](https://codecov.io/github/panzerdp/voca)
[![npm package](https://img.shields.io/npm/v/voca.svg)](https://www.npmjs.com/package/voca)

Voca is a JavaScript library for manipulating strings. [https://vocajs.com][voca]

```javascript
v.camelCase(&#x27;bird flight&#x27;);              // =&#x3e; &#x27;birdFlight&#x27;
v.<span class="apidocCodeKeywordSpan">sprintf</span>(&#x27;%s costs $%.2f&#x27;, &#x27;Tea&#x27;, 1.5); // =&#x3e; &#x27;Tea costs
 $1.50&#x27;
v.slugify(&#x27;What a wonderful world&#x27;);     // =&#x3e; &#x27;what-a-wonderful-world&#x27;
```

The Voca library offers helpful functions to make string manipulations comfortable: *change case, trim, pad, slugify,
latinise, sprintf&#x27;y, truncate, escape* and much more.  The *modular design* allows to load the entire library, or
individual functions to minimize the application builds. The library is *fully tested*, *well documented* and *long-term supported
*.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.startsWith" id="apidoc.element.voca.startsWith">
        function <span class="apidocSignatureSpan">voca.</span>startsWith
        <span class="apidocSignatureSpan">(subject, start, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startsWith(subject, start, position) {
  var subjectString = coerceToString(subject);
  var startString = toString(start);
  if (startString === null) {
    return false;
  }
  if (startString === &#x27;&#x27;) {
    return true;
  }
  position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);
  return subjectString.substr(position, startString.length) === startString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Query
* @param {string} [subject=&#x27;&#x27;] The string to verify.
* @param {string} start The starting string.
* @param {number} [position=0] The position to start searching.
* @return {boolean} Returns `true` if `subject` starts with `start` or `false` otherwise.
* @example
* v.<span class="apidocCodeKeywordSpan">startsWith</span>(&#x27;say hello to my little friend&#x27;, &#x27;say hello&#x27;);
* // =&#x3e; true
*
* v.startsWith(&#x27;tony&#x27;, &#x27;on&#x27;, 1);
* // =&#x3e; true
*
* v.startsWith(&#x27;the world is yours&#x27;, &#x27;world&#x27;);
* // =&#x3e; false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.stripBom" id="apidoc.element.voca.stripBom">
        function <span class="apidocSignatureSpan">voca.</span>stripBom
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trim$1(subject) {
  var subjectString = coerceToString(subject);
  if (subjectString === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  if (subjectString[0] === BYRE_ORDER_MARK) {
    return subjectString.substring(1);
  }
  return subjectString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.2.0
 * @memberOf Strip
 * @param {string} [subject=&#x27;&#x27;] The string to strip from.
 * @return {string} Returns the stripped string.
 * @example
 *
 * v.<span class="apidocCodeKeywordSpan">stripBom</span>(&#x27;\uFEFFsummertime sadness&#x27;);
 * // =&#x3e; &#x27;summertime sadness&#x27;
 *
 * v.stripBom(&#x27;summertime happiness&#x27;);
 * // =&#x3e; &#x27;summertime happiness&#x27;
 *
 */
function trim$1(subject) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.stripTags" id="apidoc.element.voca.stripTags">
        function <span class="apidocSignatureSpan">voca.</span>stripTags
        <span class="apidocSignatureSpan">(subject, allowableTags, replacement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trim$2(subject, allowableTags, replacement) {
  subject = coerceToString(subject);
  if (subject === &#x27;&#x27;) {
    return &#x27;&#x27;;
  }
  if (!Array.isArray(allowableTags)) {
    var allowableTagsString = coerceToString(allowableTags);
    allowableTags = allowableTagsString === &#x27;&#x27; ? [] : parseTagList(allowableTagsString);
  }
  var replacementString = coerceToString(replacement);
  var length = subject.length;
  var hasAllowableTags = allowableTags.length &#x3e; 0;
  var hasSubstring = hasSubstringAtIndex.bind(null, subject);
  var state = STATE_OUTPUT;
  var depth = 0;
  var output = &#x27;&#x27;;
  var tagContent = &#x27;&#x27;;
  var quote = null;
  for (var index = 0; index &#x3c; length; index++) {
    var char = subject[index];
    var advance = false;
    switch (char) {
      case &#x27;&#x3c;&#x27;:
        if (quote) {
          break;
        }
        if (hasSubstring(&#x27;&#x3c; &#x27;, index, false)) {
          advance = true;
          break;
        }
        if (state === STATE_OUTPUT) {
          advance = true;
          state = STATE_HTML;
          break;
        }
        if (state === STATE_HTML) {
          depth++;
          break;
        }
        advance = true;
        break;
      case &#x27;!&#x27;:
        if (state === STATE_HTML &#x26;&#x26; hasSubstring(&#x27;&#x3c;!&#x27;, index)) {
          state = STATE_EXCLAMATION;
          break;
        }
        advance = true;
        break;
      case &#x27;-&#x27;:
        if (state === STATE_EXCLAMATION &#x26;&#x26; hasSubstring(&#x27;!--&#x27;, index)) {
          state = STATE_COMMENT;
          break;
        }
        advance = true;
        break;
      case &#x27;&#x22;&#x27;:
      case &#x22;&#x27;&#x22;:
        if (state === STATE_HTML) {
          if (quote === char) {
            quote = null;
          } else if (!quote) {
            quote = char;
          }
        }
        advance = true;
        break;
      case &#x27;E&#x27;:
      case &#x27;e&#x27;:
        if (state === STATE_EXCLAMATION &#x26;&#x26; hasSubstring(&#x27;doctype&#x27;, index)) {
          state = STATE_HTML;
          break;
        }
        advance = true;
        break;
      case &#x27;&#x3e;&#x27;:
        if (depth &#x3e; 0) {
          depth--;
          break;
        }
        if (quote) {
          break;
        }
        if (state === STATE_HTML) {
          quote = null;
          state = STATE_OUTPUT;
          if (hasAllowableTags) {
            tagContent += &#x27;&#x3e;&#x27;;
            var tagName = parseTagName(tagContent);
            if (allowableTags.indexOf(tagName.toLowerCase()) !== -1) {
              output += tagContent;
            } else {
              output += replacementString;
            }
            tagContent = &#x27;&#x27;;
          } else {
            output += replacementString;
          }
          break;
        }
        if (state === STATE_EXCLAMATION || state === STATE_COMMENT &#x26;&#x26; hasSubstring(&#x27;--&#x3e;&#x27;, index)) {
          quote = null;
          state = STATE_OUTPUT;
          tagContent = &#x27;&#x27;;
          break;
        }
        advance = true;
        break;
      default:
        advance = true;
    }
    if (advance) {
      switch (state) {
        case STATE_OUTPUT:
          output += char;
          break;
        case STATE_HTML:
          if (hasAllowableTags) {
            tagContent += char;
          }
          break;
      }
    }
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @memberOf Strip
* @param {string} [subject=&#x27;&#x27;] The string to strip from.
* @param {string|Array} [allowableTags] The string `&#x27;&#x3c;tag1&#x3e;&#x3c;tag2&#x3e;&#x27;` or array `[&#x27;tag1&#x27;, &#
x27;tag2&#x27;]` of tags that should not be stripped.
* @param {string} [replacement=&#x27;&#x27;] The string to replace the stripped tag.
* @return {string} Returns the stripped string.
* @example
*
* v.<span class="apidocCodeKeywordSpan">stripTags</span>(&#x27;&#x3c;span&#x3e;&#x3c;a href=&#x22;#&#x22;&#x3e;Summer&#x3c;/a&#x3e
; is nice&#x3c;/span&#x3e;&#x27;);
* // =&#x3e; &#x27;Summer is nice&#x27;
*
* v.stripTags(&#x27;&#x3c;span&#x3e;&#x3c;i&#x3e;Winter&#x3c;/i&#x3e; is &#x3c;b&#x3e;cold&#x3c;/b&#x3e;&#x3c;/span&#x3e;&#x27;, [&#
x27;b&#x27;, &#x27;i&#x27;]);
* // =&#x3e; &#x27;&#x3c;i&#x3e;Winter&#x3c;/i&#x3e; is &#x3c;b&#x3e;cold&#x3c;/b&#x3e;&#x27;
*
* v.stripTags(&#x27;Sun&#x3c;br/&#x3e;set&#x27;, &#x27;&#x27;, &#x27;-&#x27;);
* // =&#x3e; &#x27;Sun-set&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.substr" id="apidoc.element.voca.substr">
        function <span class="apidocSignatureSpan">voca.</span>substr
        <span class="apidocSignatureSpan">(subject, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function substr(subject, start, length) {
  return coerceToString(subject).substr(start, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var restToLowerCaseBoolean = coerceToBoolean(restToLower);
 if (subjectString === &#x27;&#x27;) {
   return &#x27;&#x27;;
 }
 if (restToLowerCaseBoolean) {
   subjectString = subjectString.toLowerCase();
 }
 return subjectString.<span class="apidocCodeKeywordSpan">substr</span>(0, 1).toUpperCase() + subjectString.substr(1);
}

/**
* Converts the `subject` to lower case.
*
* @function lowerCase
* @static
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.substring" id="apidoc.element.voca.substring">
        function <span class="apidocSignatureSpan">voca.</span>substring
        <span class="apidocSignatureSpan">(subject, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function substring(subject, start, end) {
  return coerceToString(subject).substring(start, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @static
* @since 1.0.0
* @memberOf Chop
* @param  {string} [subject=&#x27;&#x27;]         The string to extract from.
* @param  {number} start                The position to start extraction.
* @param  {number} [end=subject.length] The position to end extraction.
* @return {string}                      Returns the extracted string.
* @note Uses native `String.prototype.<span class="apidocCodeKeywordSpan">substring</span>()`
* @example
* v.substring(&#x27;beach&#x27;, 1);
* // =&#x3e; &#x27;each&#x27;
*
* v.substring(&#x27;ocean&#x27;, 1, 3);
* // =&#x3e; &#x27;ea&#x27;
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.swapCase" id="apidoc.element.voca.swapCase">
        function <span class="apidocSignatureSpan">voca.</span>swapCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function swapCase(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.split(&#x27;&#x27;).reduce(swapAndConcat, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function swapCase
 * @static
 * @since 1.3.0
 * @memberOf Case
 * @param  {string} [subject=&#x27;&#x27;] The string to swap the case.
 * @return {string}              Returns the converted string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">swapCase</span>(&#x27;League of Shadows&#x27;);
 * // =&#x3e; &#x27;lEAGE OF sHADOWS&#x27;
 *
 * v.swapCase(&#x27;2 Bees&#x27;);
 * // =&#x3e; &#x27;2 bEES&#x27;
 */
function swapCase(subject) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.titleCase" id="apidoc.element.voca.titleCase">
        function <span class="apidocSignatureSpan">voca.</span>titleCase
        <span class="apidocSignatureSpan">(subject, ignoreWords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function titleCase(subject, ignoreWords) {
  var subjectString = coerceToString(subject);
  var ignoreWordsArray = Array.isArray(ignoreWords) ? ignoreWords : [];
  var wordsRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
  return subjectString.replace(wordsRegExp, function (word) {
    var lowerCaseWord = word.toLowerCase();
    return ignoreWordsArray.indexOf(lowerCaseWord) !== -1 ? lowerCaseWord : capitalize(lowerCaseWord, true);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.2.0
 * @memberOf Case
 * @param  {string} [subject=&#x27;&#x27;] The string to convert to title case.
 * @param  {Array} [ignoreWords] The words that should not be capitalized.
 * @return {string}              Returns the title case string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">titleCase</span>(&#x27;learning to fly&#x27;);
 * // =&#x3e; &#x27;Learning To Fly&#x27;
 *
 * v.titleCase(&#x27;another brick in the wall&#x27;, [&#x27;in&#x27;, &#x27;the&#x27;]);
 * // =&#x3e; &#x27;Another Brick in the Wall&#x27;
 */
function titleCase(subject, ignoreWords) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.tr" id="apidoc.element.voca.tr">
        function <span class="apidocSignatureSpan">voca.</span>tr
        <span class="apidocSignatureSpan">(subject, from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tr(subject, from, to) {
  var subjectString = coerceToString(subject);
  var keys = void 0;
  var values = void 0;
  if (isString(from) &#x26;&#x26; isString(to)) {
    keys = from.split(&#x27;&#x27;);
    values = to.split(&#x27;&#x27;);
  } else {
    var _extractKeysAndValues = extractKeysAndValues(nilDefault(from, {}));

    var _extractKeysAndValues2 = _slicedToArray(_extractKeysAndValues, 2);

    keys = _extractKeysAndValues2[0];
    values = _extractKeysAndValues2[1];
  }
  if (keys.length === 0) {
    return subjectString;
  }
  var result = &#x27;&#x27;;
  var valuesLength = values.length;
  var keysLength = keys.length;
  for (var index = 0; index &#x3c; subjectString.length; index++) {
    var isMatch = false;
    var matchValue = void 0;
    for (var keyIndex = 0; keyIndex &#x3c; keysLength &#x26;&#x26; keyIndex &#x3c; valuesLength; keyIndex++) {
      var key = keys[keyIndex];
      if (subjectString.substr(index, key.length) === key) {
        isMatch = true;
        matchValue = values[keyIndex];
        index = index + key.length - 1;
        break;
      }
    }
    result += isMatch ? matchValue : subjectString[index];
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.3.0
* @memberOf Manipulate
* @param  {string} [subject=&#x27;&#x27;] The string to translate.
* @param  {string|Object} from The string of characters to translate from. Or an object, then the object keys are replaced with
corresponding values (longest keys are tried first).
* @param  {string} to The string of characters to translate to. Ignored when `from` is an object.
* @return {string} Returns the translated string.
* @example
* v.<span class="apidocCodeKeywordSpan">tr</span>(&#x27;hello&#x27;, &#x27;el&#x27;, &#x27;ip&#x27;);
* // =&#x3e; &#x27;hippo&#x27;
*
* v.tr(&#x27;légèreté&#x27;, &#x27;éè&#x27;, &#x27;ee&#x27;);
* // =&#x3e; &#x27;legerete&#x27;
*
* v.tr(&#x27;Yes. The fire rises.&#x27;, {
*   &#x27;Yes&#x27;: &#x27;Awesome&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.trim" id="apidoc.element.voca.trim">
        function <span class="apidocSignatureSpan">voca.</span>trim
        <span class="apidocSignatureSpan">(subject, whitespace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trim(subject, whitespace) {
  var subjectString = coerceToString(subject);
  if (whitespace === &#x27;&#x27; || subjectString === &#x27;&#x27;) {
    return subjectString;
  }
  var whitespaceString = toString(whitespace);
  if (isNil(whitespaceString)) {
    return subjectString.trim();
  }
  return trimRight(trimLeft(subjectString, whitespaceString), whitespaceString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### CommonJS modules

Then in your application require the entire library:

```javascript
var v = require(&#x27;voca&#x27;);
v.<span class="apidocCodeKeywordSpan">trim</span>(&#x27; Hello World! &#x27;);            // =&#x3e; &#x27;Hello World&#x27;
v.sprintf(&#x27;%d red %s&#x27;, 3, &#x27;apples&#x27;); // =&#x3e; &#x27;3 red apples&#x27;
```

Or require individual functions:

```javascript
var words = require(&#x27;voca/words&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.trimLeft" id="apidoc.element.voca.trimLeft">
        function <span class="apidocSignatureSpan">voca.</span>trimLeft
        <span class="apidocSignatureSpan">(subject, whitespace$$1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trimLeft(subject, whitespace$$1) {
  var subjectString = coerceToString(subject);
  if (whitespace$$1 === &#x27;&#x27; || subjectString === &#x27;&#x27;) {
    return subjectString;
  }
  var whitespaceString = toString(whitespace$$1);
  if (isNil(whitespaceString)) {
    return subjectString.replace(REGEXP_TRIM_LEFT, &#x27;&#x27;);
  }
  var matchWhitespace = true;
  return reduce$1.call(subjectString, function (trimmed, character) {
    if (matchWhitespace &#x26;&#x26; includes(whitespaceString, character)) {
      return trimmed;
    }
    matchWhitespace = false;
    return trimmed + character;
  }, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Manipulate
 * @param {string} [subject=&#x27;&#x27;] The string to trim.
 * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.
 * @return {string} Returns the trimmed string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">trimLeft</span>(&#x27;  Starship Troopers&#x27;);
 * // =&#x3e; &#x27;Starship Troopers&#x27;
 *
 * v.trimLeft(&#x27;***Mobile Infantry&#x27;, &#x27;*&#x27;);
 * // =&#x3e; &#x27;Mobile Infantry&#x27;
 */
function trimLeft(subject, whitespace$$1) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.trimRight" id="apidoc.element.voca.trimRight">
        function <span class="apidocSignatureSpan">voca.</span>trimRight
        <span class="apidocSignatureSpan">(subject, whitespace$$1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trimRight(subject, whitespace$$1) {
  var subjectString = coerceToString(subject);
  if (whitespace$$1 === &#x27;&#x27; || subjectString === &#x27;&#x27;) {
    return subjectString;
  }
  var whitespaceString = toString(whitespace$$1);
  if (isNil(whitespaceString)) {
    return subjectString.replace(REGEXP_TRIM_RIGHT, &#x27;&#x27;);
  }
  var matchWhitespace = true;
  return reduceRight.call(subjectString, function (trimmed, character) {
    if (matchWhitespace &#x26;&#x26; includes(whitespaceString, character)) {
      return trimmed;
    }
    matchWhitespace = false;
    return character + trimmed;
  }, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Manipulate
 * @param {string} [subject=&#x27;&#x27;] The string to trim.
 * @param {string} [whitespace=whitespace] The whitespace characters to trim. List all characters that you want to be stripped.
 * @return {string} Returns the trimmed string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">trimRight</span>(&#x27;the fire rises   &#x27;);
 * // =&#x3e; &#x27;the fire rises&#x27;
 *
 * v.trimRight(&#x27;do you feel in charge?!!!&#x27;, &#x27;!&#x27;);
 * // =&#x3e; &#x27;do you feel in charge?&#x27;
 */
function trimRight(subject, whitespace$$1) {
var subjectString = coerceToString(subject);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.truncate" id="apidoc.element.voca.truncate">
        function <span class="apidocSignatureSpan">voca.</span>truncate
        <span class="apidocSignatureSpan">(subject, length, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function truncate(subject, length, end) {
  var subjectString = coerceToString(subject);
  var lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
  var endString = coerceToString(end, &#x27;...&#x27;);
  if (lengthInt &#x3e;= subjectString.length) {
    return subjectString;
  }
  return subjectString.substr(0, length - endString.length) + endString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Chop
* @param  {string} [subject=&#x27;&#x27;] The string to truncate.
* @param  {int}    length       The length to truncate the string.
* @param  {string} [end=&#x27;...&#x27;]  The string to be added at the end.
* @return {string}              Returns the truncated string.
* @example
* v.<span class="apidocCodeKeywordSpan">truncate</span>(&#x27;Once upon a time&#x27;, 7);
* // =&#x3e; &#x27;Once...&#x27;
*
* v.truncate(&#x27;Good day, Little Red Riding Hood&#x27;, 14, &#x27; (...)&#x27;);
* // =&#x3e; &#x27;Good day (...)&#x27;
*
* v.truncate(&#x27;Once upon&#x27;, 10);
* // =&#x3e; &#x27;Once upon&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.unescapeHtml" id="apidoc.element.voca.unescapeHtml">
        function <span class="apidocSignatureSpan">voca.</span>unescapeHtml
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unescapeHtml(subject) {
  var subjectString = coerceToString(subject);
  return characters.reduce(reduceUnescapedString, subjectString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function unescapeHtml
 * @static
 * @since 1.0.0
 * @memberOf Escape
 * @param  {string} [subject=&#x27;&#x27;] The string to unescape.
 * @return {string}              Returns the unescaped string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">unescapeHtml</span>(&#x27;&#x26;lt;p&#x26;gt;wonderful world&#x26;lt;/p&#x26;gt;&#x27;);
 * // =&#x3e; &#x27;&#x3c;p&#x3e;wonderful world&#x3c;/p&#x3e;&#x27;
 */
function unescapeHtml(subject) {
  var subjectString = coerceToString(subject);
  return characters.reduce(reduceUnescapedString, subjectString);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.upperCase" id="apidoc.element.voca.upperCase">
        function <span class="apidocSignatureSpan">voca.</span>upperCase
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upperCase(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.toUpperCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @function upperCase
 * @static
 * @since 1.0.0
 * @memberOf Case
 * @param  {string} [subject=&#x27;&#x27;] The string to convert to upper case.
 * @return {string}              Returns the upper case string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">upperCase</span>(&#x27;school&#x27;);
 * // =&#x3e; &#x27;SCHOOL&#x27;
 */
function upperCase(subject) {
  var subjectString = coerceToString(subject);
  return subjectString.toUpperCase();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.vprintf" id="apidoc.element.voca.vprintf">
        function <span class="apidocSignatureSpan">voca.</span>vprintf
        <span class="apidocSignatureSpan">(format, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function vprintf(format, replacements) {
  return sprintf.apply(undefined, [format].concat(_toConsumableArray(nilDefault(replacements, []))));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 * @since 1.0.0
 * @memberOf Format
 * @param  {string} format=&#x27;&#x27;]  The format string.
 * @param  {Array} replacements The array of replacements to produce the string.
 * @return {string}             Returns the produced string.
 * @example
 * v.<span class="apidocCodeKeywordSpan">vprintf</span>(&#x27;%s&#x27;, [&#x27;Welcome&#x27;])
 * // =&#x3e; &#x27;Welcome&#x27;
 *
 * v.vprintf(&#x27;%s has %d apples&#x27;, [&#x27;Alexandra&#x27;, 3]);
 * // =&#x3e; &#x27;Alexandra has 3 apples&#x27;
 */
function vprintf(format, replacements) {
return sprintf.apply(undefined, [format].concat(_toConsumableArray(nilDefault(replacements, []))));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.wordWrap" id="apidoc.element.voca.wordWrap">
        function <span class="apidocSignatureSpan">voca.</span>wordWrap
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wordWrap(subject) {
  var options = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : {};

  var subjectString = coerceToString(subject);

  var _determineOptions = determineOptions(options),
      width = _determineOptions.width,
      newLine = _determineOptions.newLine,
      indent = _determineOptions.indent,
      cut = _determineOptions.cut;

  if (subjectString === &#x27;&#x27; || width &#x3c;= 0) {
    return indent;
  }
  var subjectLength = subjectString.length;
  var substring = subjectString.substring.bind(subjectString);
  var offset = 0;
  var wrappedLine = &#x27;&#x27;;
  while (subjectLength - offset &#x3e; width) {
    if (subjectString[offset] === &#x27; &#x27;) {
      offset++;
      continue;
    }
    var spaceToWrapAt = subjectString.lastIndexOf(&#x27; &#x27;, width + offset);
    if (spaceToWrapAt &#x3e;= offset) {
      wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;
      offset = spaceToWrapAt + 1;
    } else {
      if (cut) {
        wrappedLine += indent + substring(offset, width + offset) + newLine;
        offset += width;
      } else {
        spaceToWrapAt = subjectString.indexOf(&#x27; &#x27;, width + offset);
        if (spaceToWrapAt &#x3e;= 0) {
          wrappedLine += indent + substring(offset, spaceToWrapAt) + newLine;
          offset = spaceToWrapAt + 1;
        } else {
          wrappedLine += indent + substring(offset);
          offset = subjectLength;
        }
      }
    }
  }
  if (offset &#x3c; subjectLength) {
    wrappedLine += indent + substring(offset);
  }
  return wrappedLine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {string} [options.newLine=&#x27;\n&#x27;] The string to add at the end of line.
* @param  {string} [options.indent=&#x27;&#x27;]  The string to intend the line.
* @param  {boolean} [options.cut=false] When `false` (default) does not split the word even if word length is bigger than `width
`. &#x3c;br/&#x3e;
*                                       When `true` breaks the word that has length bigger than `width`.
*
* @return {string} Returns wrapped string.
* @example
* v.<span class="apidocCodeKeywordSpan">wordWrap</span>(&#x27;Hello world&#x27;, {
*   width: 5
* });
* // =&#x3e; &#x27;Hello\nworld&#x27;
*
* v.wordWrap(&#x27;Hello world&#x27;, {
*   width: 5,
*   newLine: &#x27;&#x3c;br/&#x3e;&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.words" id="apidoc.element.voca.words">
        function <span class="apidocSignatureSpan">voca.</span>words
        <span class="apidocSignatureSpan">(subject, pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function words(subject, pattern, flags) {
  var subjectString = coerceToString(subject);
  var patternRegExp = void 0;
  if (isNil(pattern)) {
    patternRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
  } else if (pattern instanceof RegExp) {
    patternRegExp = pattern;
  } else {
    var flagsString = toString(nilDefault(flags, &#x27;&#x27;));
    patternRegExp = new RegExp(toString(pattern), flagsString);
  }
  return nilDefault(subjectString.match(patternRegExp), []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @since 1.0.0
* @memberOf Split
* @param {string} [subject=&#x27;&#x27;] The string to split into words.
* @param {string|RegExp} [pattern] The pattern to watch words. If `pattern` is not RegExp, it is transformed to `new RegExp(pattern
, flags)`.
* @param {string} [flags=&#x27;&#x27;] The regular expression flags. Applies when `pattern` is string type.
* @return {Array} Returns the array of words.
* @example
* v.<span class="apidocCodeKeywordSpan">words</span>(&#x27;gravity can cross dimensions&#x27;);
* // =&#x3e; [&#x27;gravity&#x27;, &#x27;can&#x27;, &#x27;cross&#x27;, &#x27;dimensions&#x27;]
*
* v.words(&#x27;GravityCanCrossDimensions&#x27;);
* // =&#x3e; [&#x27;Gravity&#x27;, &#x27;Can&#x27;, &#x27;Cross&#x27;, &#x27;Dimensions&#x27;]
*
* v.words(&#x27;Gravity - can cross dimensions!&#x27;);
* // =&#x3e; [&#x27;Gravity&#x27;, &#x27;can&#x27;, &#x27;cross&#x27;, &#x27;dimensions&#x27;]
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voca.conversion_specification" id="apidoc.module.voca.conversion_specification">module voca.conversion_specification</a></h1>


    <h2>
        <a href="#apidoc.element.voca.conversion_specification.conversion_specification" id="apidoc.element.voca.conversion_specification.conversion_specification">
        function <span class="apidocSignatureSpan">voca.</span>conversion_specification
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConversionSpecification(properties) {

<span class="apidocCodeCommentSpan">  /**
   * The percent characters from conversion specification.
   *
   * @ignore
   * @name ConversionSpecification#percent
   * @type {string}
   */
</span>  this.percent = properties.percent;

  /**
   *  The sign specifier to force a sign to be used on a number.
   *
   * @ignore
   * @name ConversionSpecification#signSpecifier
   * @type {string}
   */
  this.signSpecifier = properties.signSpecifier;

  /**
   * The padding specifier that says what padding character will be used.
   *
   * @ignore
   * @name ConversionSpecification#paddingSpecifier
   * @type {string}
   */
  this.paddingSpecifier = properties.paddingSpecifier;

  /**
   * The alignment specifier that says if the result should be left-justified or right-justified.
   *
   * @ignore
   * @name ConversionSpecification#alignmentSpecifier
   * @type {string}
   */
  this.alignmentSpecifier = properties.alignmentSpecifier;

  /**
   * The width specifier how many characters this conversion should result in.
   *
   * @ignore
   * @name ConversionSpecification#width
   * @type {number}
   */
  this.width = properties.width;

  /**
   * The precision specifier says how many decimal digits should be displayed for floating-point numbers.
   *
   * @ignore
   * @name ConversionSpecification#precision
   * @type {number}
   */
  this.precision = properties.precision;

  /**
   * The type specifier says what type the argument data should be treated as.
   *
   * @ignore
   * @name ConversionSpecification#typeSpecifier
   * @type {string}
   */
  this.typeSpecifier = properties.typeSpecifier;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voca.conversion_specification.prototype" id="apidoc.module.voca.conversion_specification.prototype">module voca.conversion_specification.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.voca.conversion_specification.prototype.getPaddingCharacter" id="apidoc.element.voca.conversion_specification.prototype.getPaddingCharacter">
        function <span class="apidocSignatureSpan">voca.conversion_specification.prototype.</span>getPaddingCharacter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPaddingCharacter = function () {
  var paddingCharacter = (0, _nil_default2.default)(this.paddingSpecifier, &#x27; &#x27;);
  if (paddingCharacter.length === 2 &#x26;&#x26; paddingCharacter[0] === _const2.default.LITERAL_SINGLE_QUOTE) {
    paddingCharacter = paddingCharacter[1];
  }
  return paddingCharacter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
function alignAndPad(subject, conversion) {
 var width = conversion.width;
 if (isNil(width) || subject.length &#x3e;= width) {
   return subject;
 }
 var padType = conversion.alignmentSpecifier === Const.LITERAL_MINUS ? padRight : padLeft;
 return padType(subject, width, conversion.<span class="apidocCodeKeywordSpan">getPaddingCharacter</span>());
}

/**
* Add sign to the formatted number.
*
* @ignore
* @name addSignToFormattedNumber
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.conversion_specification.prototype.isPercentLiteral" id="apidoc.element.voca.conversion_specification.prototype.isPercentLiteral">
        function <span class="apidocSignatureSpan">voca.conversion_specification.prototype.</span>isPercentLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPercentLiteral = function () {
  return _const2.default.LITERAL_PERCENT_SPECIFIER === this.percent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    signSpecifier: signSpecifier,
    paddingSpecifier: paddingSpecifier,
    alignmentSpecifier: alignmentSpecifier,
    width: coerceToNumber(widthSpecifier, null),
    precision: coerceToNumber(precisionSpecifier, null),
    typeSpecifier: typeSpecifier
  });
  if (conversion.<span class="apidocCodeKeywordSpan">isPercentLiteral</span>()) {
    return conversionSpecification.slice(1);
  }
  var actualReplacementIndex = replacementIndex.getIndexByPosition(position);
  replacementIndex.incrementOnEmptyPosition(position);
  validate(actualReplacementIndex, replacements.length, conversion);
  return compute(replacements[actualReplacementIndex], conversion);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voca.diacritics_map" id="apidoc.module.voca.diacritics_map">module voca.diacritics_map</a></h1>


    <h2>
        <a href="#apidoc.element.voca.diacritics_map.getLatinCharacter" id="apidoc.element.voca.diacritics_map.getLatinCharacter">
        function <span class="apidocSignatureSpan">voca.diacritics_map.</span>getLatinCharacter
        <span class="apidocSignatureSpan">(character)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLatinCharacter(character) {
  var characterWithoutDiacritic = getDiacriticsMap()[character];
  return characterWithoutDiacritic ? characterWithoutDiacritic : character;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voca.surrogate_pair" id="apidoc.module.voca.surrogate_pair">module voca.surrogate_pair</a></h1>


    <h2>
        <a href="#apidoc.element.voca.surrogate_pair.getAstralNumberFromSurrogatePair" id="apidoc.element.voca.surrogate_pair.getAstralNumberFromSurrogatePair">
        function <span class="apidocSignatureSpan">voca.surrogate_pair.</span>getAstralNumberFromSurrogatePair
        <span class="apidocSignatureSpan">(highSurrogate, lowSurrogate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAstralNumberFromSurrogatePair(highSurrogate, lowSurrogate) {
  return (highSurrogate - HIGH_SURROGATE_START) * 0x400 + lowSurrogate - LOW_SURROGATE_START + 0x10000;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.surrogate_pair.isHighSurrogate" id="apidoc.element.voca.surrogate_pair.isHighSurrogate">
        function <span class="apidocSignatureSpan">voca.surrogate_pair.</span>isHighSurrogate
        <span class="apidocSignatureSpan">(codePoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isHighSurrogate(codePoint) {
  return codePoint &#x3e;= HIGH_SURROGATE_START &#x26;&#x26; codePoint &#x3c;= HIGH_SURROGATE_END;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voca.surrogate_pair.isLowSurrogate" id="apidoc.element.voca.surrogate_pair.isLowSurrogate">
        function <span class="apidocSignatureSpan">voca.surrogate_pair.</span>isLowSurrogate
        <span class="apidocSignatureSpan">(codePoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLowSurrogate(codePoint) {
  return codePoint &#x3e;= LOW_SURROGATE_START &#x26;&#x26; codePoint &#x3c;= LOW_SURROGATE_END;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
